import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

type ExportFormat = 'playwright' | 'newman' | 'github-actions' | 'gitlab-ci' | 'jenkins'

export async function POST(request: NextRequest) {
  try {
    const { collectionId, environmentId, format } = await request.json()

    if (!collectionId || !format) {
      return NextResponse.json(
        { success: false, error: 'Collection ID and format are required' },
        { status: 400 }
      )
    }

    // Fetch collection with requests
    const collection = await prisma.apiCollection.findUnique({
      where: { id: collectionId },
      include: {
        requests: {
          orderBy: { order: 'asc' },
          include: {
            assertions: true
          }
        }
      }
    })

    if (!collection) {
      return NextResponse.json(
        { success: false, error: 'Collection not found' },
        { status: 404 }
      )
    }

    // Fetch environment if specified
    let environment = null
    if (environmentId) {
      environment = await prisma.environment.findUnique({
        where: { id: environmentId }
      })
    }

    // Generate code based on format
    let code: string
    switch (format) {
      case 'playwright':
        code = generatePlaywrightCode(collection, environment)
        break
      case 'newman':
        code = generateNewmanCode(collection, environment)
        break
      case 'github-actions':
        code = generateGitHubActionsCode(collection)
        break
      case 'gitlab-ci':
        code = generateGitLabCICode(collection)
        break
      case 'jenkins':
        code = generateJenkinsCode(collection)
        break
      default:
        return NextResponse.json(
          { success: false, error: 'Invalid export format' },
          { status: 400 }
        )
    }

    return NextResponse.json({
      success: true,
      code
    })

  } catch (error) {
    console.error('CI/CD export error:', error)
    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to generate export'
      },
      { status: 500 }
    )
  }
}

/**
 * Generate Playwright test code
 */
function generatePlaywrightCode(collection: any, environment: any): string {
  const envVars = environment ? JSON.parse(environment.variables) : {}
  const baseUrl = envVars.baseUrl || 'https://api.example.com'

  let code = `import { test, expect } from '@playwright/test'

/**
 * API Test Collection: ${collection.title}
 * ${collection.description || 'Generated by QA Nexus'}
 */

`

  if (environment) {
    code += `// Environment: ${environment.name}\n`
    code += `const baseUrl = '${baseUrl}'\n\n`
  }

  code += `test.describe('${collection.title}', () => {\n`

  for (const req of collection.requests) {
    const method = req.method.toUpperCase()
    const headers = req.headers ? JSON.parse(req.headers) : {}
    const queryParams = req.queryParams ? JSON.parse(req.queryParams) : {}
    const body = req.body ? JSON.parse(req.body) : null

    // Replace environment variables
    let url = req.url
    if (environment) {
      Object.keys(envVars).forEach(key => {
        url = url.replace(new RegExp(`{{${key}}}`, 'g'), envVars[key])
      })
    }

    code += `
  test('${req.title}', async ({ request }) => {
    const response = await request.${method.toLowerCase()}('${url}'`

    // Add request options
    const options: string[] = []

    if (Object.keys(headers).length > 0) {
      options.push(`headers: ${JSON.stringify(headers, null, 6)}`)
    }

    if (Object.keys(queryParams).length > 0) {
      options.push(`params: ${JSON.stringify(queryParams, null, 6)}`)
    }

    if (body && ['POST', 'PUT', 'PATCH'].includes(method)) {
      options.push(`data: ${JSON.stringify(body, null, 6)}`)
    }

    if (options.length > 0) {
      code += `, {\n      ${options.join(',\n      ')}\n    }`
    }

    code += `)

    // Status code assertion
    expect(response.status()).toBe(200)
`

    // Add custom assertions
    if (req.assertions && req.assertions.length > 0) {
      code += `
    // Response validations
    const data = await response.json()
`
      for (const assertion of req.assertions) {
        if (assertion.type === 'STATUS_CODE') {
          code += `    expect(response.status()).toBe(${assertion.expectedValue})\n`
        } else if (assertion.type === 'RESPONSE_BODY' && assertion.field) {
          code += `    expect(data.${assertion.field}).toBeDefined()\n`
        }
      }
    }

    code += `  })
`
  }

  code += `})
`

  return code
}

/**
 * Generate Newman/Postman collection JSON
 */
function generateNewmanCode(collection: any, environment: any): string {
  const postmanCollection = {
    info: {
      name: collection.title,
      description: collection.description || `Generated by QA Nexus`,
      schema: 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json'
    },
    item: collection.requests.map((req: any) => {
      const headers = req.headers ? JSON.parse(req.headers) : {}
      const queryParams = req.queryParams ? JSON.parse(req.queryParams) : {}
      const body = req.body ? JSON.parse(req.body) : null

      return {
        name: req.title,
        request: {
          method: req.method.toUpperCase(),
          header: Object.entries(headers).map(([key, value]) => ({
            key,
            value: String(value)
          })),
          url: {
            raw: req.url,
            query: Object.entries(queryParams).map(([key, value]) => ({
              key,
              value: String(value)
            }))
          },
          body: body ? {
            mode: 'raw',
            raw: JSON.stringify(body, null, 2),
            options: {
              raw: {
                language: 'json'
              }
            }
          } : undefined
        },
        event: req.assertions && req.assertions.length > 0 ? [{
          listen: 'test',
          script: {
            exec: req.assertions.map((a: any) => {
              if (a.type === 'STATUS_CODE') {
                return `pm.test("Status code is ${a.expectedValue}", () => {
  pm.response.to.have.status(${a.expectedValue});
});`
              }
              return `pm.test("${a.field} exists", () => {
  pm.expect(pm.response.json()).to.have.property('${a.field}');
});`
            })
          }
        }] : undefined
      }
    })
  }

  return JSON.stringify(postmanCollection, null, 2)
}

/**
 * Generate GitHub Actions workflow
 */
function generateGitHubActionsCode(collection: any): string {
  return `name: API Tests - ${collection.title}

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 */6 * * *'  # Run every 6 hours

jobs:
  api-tests:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install Playwright
        run: |
          npm install -D @playwright/test
          npx playwright install

      - name: Run API tests
        run: npx playwright test
        env:
          API_BASE_URL: \${{ secrets.API_BASE_URL }}
          API_KEY: \${{ secrets.API_KEY }}

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: playwright-report
          path: playwright-report/
          retention-days: 30

      - name: Publish test results
        if: always()
        uses: dorny/test-reporter@v1
        with:
          name: API Test Results
          path: 'test-results/**/*.xml'
          reporter: java-junit
`
}

/**
 * Generate GitLab CI pipeline
 */
function generateGitLabCICode(collection: any): string {
  return `# GitLab CI Pipeline for ${collection.title}

stages:
  - test

api-tests:
  stage: test
  image: node:18

  before_script:
    - npm install -D @playwright/test
    - npx playwright install --with-deps

  script:
    - npx playwright test

  artifacts:
    when: always
    paths:
      - playwright-report/
      - test-results/
    reports:
      junit: test-results/**/*.xml
    expire_in: 30 days

  only:
    - merge_requests
    - main
    - develop

# Scheduled nightly tests
api-tests-scheduled:
  extends: api-tests
  only:
    - schedules
  variables:
    TEST_ENV: "production"
`
}

/**
 * Generate Jenkins pipeline
 */
function generateJenkinsCode(collection: any): string {
  return `// Jenkins Pipeline for ${collection.title}

pipeline {
  agent any

  environment {
    API_BASE_URL = credentials('api-base-url')
    API_KEY = credentials('api-key')
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Install Dependencies') {
      steps {
        sh '''
          npm install -D @playwright/test
          npx playwright install --with-deps
        '''
      }
    }

    stage('Run API Tests') {
      steps {
        sh 'npx playwright test'
      }
    }
  }

  post {
    always {
      // Publish HTML report
      publishHTML([
        allowMissing: false,
        alwaysLinkToLastBuild: true,
        keepAll: true,
        reportDir: 'playwright-report',
        reportFiles: 'index.html',
        reportName: 'API Test Report',
        reportTitles: '${collection.title}'
      ])

      // Archive test results
      archiveArtifacts artifacts: 'test-results/**/*.xml', allowEmptyArchive: true
      junit 'test-results/**/*.xml'
    }

    failure {
      // Send notification on failure
      emailext(
        subject: "API Tests Failed: \${env.JOB_NAME} - Build #\${env.BUILD_NUMBER}",
        body: """
          <p>API test execution failed.</p>
          <p>Job: \${env.JOB_NAME}</p>
          <p>Build: \${env.BUILD_NUMBER}</p>
          <p>Check console output: \${env.BUILD_URL}</p>
        """,
        to: 'qa-team@example.com',
        mimeType: 'text/html'
      )
    }

    success {
      echo 'All API tests passed successfully!'
    }
  }
}
`
}
